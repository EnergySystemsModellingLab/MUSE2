#!/usr/bin/env python3
#
# A script to generate markdown documentation from table schemas.

from table2md import MarkdownTable
import yaml
from pathlib import Path

_DOCS_DIR = Path(__file__).parent
_SCHEMA_DIR = _DOCS_DIR.parent / "schemas" / "input"
_FILE_ORDER = {
    "Time slices": ["time_slices"],
    "Regions": ["regions"],
}


def generate_markdown() -> str:
    out = (
        "# Input file format\n"
        f"<!-- Automatically generated by {__name__}.py. Do not edit manually. -->\n"
        "<!-- markdownlint-disable MD013 -->\n"
        "<!-- markdownlint-disable MD033 -->\n"
    )

    for title, patterns in _FILE_ORDER.items():
        out += f"\n## {title}\n"

        for pattern in patterns:
            paths = map(str, _SCHEMA_DIR.glob(f"{pattern}.yaml"))
            for path in map(Path, sorted(paths)):
                out += process_file(path)

    return out


def process_file(path: Path) -> str:
    out = f"\n### `{path.stem}.csv`\n\n"
    with path.open() as f:
        data = yaml.load(f, Loader=yaml.Loader)

    info = data["title"]
    if desc := data.get("description", ""):
        info = f"{add_full_stop(info)} {desc}"
    out += f"{add_full_stop(info)}\n\n"

    try:
        out += fields2table(data["fields"])
    except KeyError:
        print(f"MISSING VALUE IN {path}")
        raise

    return out


def add_full_stop(s: str) -> str:
    s = s.rstrip()
    if s == "" or s.endswith("."):
        return s
    else:
        return f"{s}."


def fields2table(fields: list[dict[str, str]]) -> str:
    data = [
        {
            "Field": f"`{f['name']}`",
            "Title": f["title"],
            # MarkdownTable can't handle newlines, so replace with HTML equivalent
            "Description": add_full_stop(f.get("description", ""))
            .replace("\n\n", "<br /><br />")
            .replace("\n", " "),
        }
        for f in fields
    ]

    return str(MarkdownTable.from_dicts(data))


if __name__ == "__main__":
    print(generate_markdown(), end="")
